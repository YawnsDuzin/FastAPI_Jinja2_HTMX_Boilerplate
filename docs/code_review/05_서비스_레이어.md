# 05. 서비스 레이어

## 5.1 개요

서비스 레이어는 **비즈니스 로직을 캡슐화**하는 중간 계층입니다. 라우터(Controller)와 모델(Data) 사이에 위치하며, 애플리케이션의 핵심 로직을 담당합니다.

### 관련 파일

- `app/services/auth.py` - 인증 서비스
- `app/services/user.py` - 사용자 서비스
- `app/services/item.py` - 아이템 서비스

### 계층 구조

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Presentation Layer (라우터)                      │
│            • HTTP 요청/응답 처리                                    │
│            • 의존성 주입                                            │
│            • 템플릿 렌더링                                          │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    Service Layer (서비스)                           │
│            • 비즈니스 로직 처리                                     │
│            • 트랜잭션 관리                                          │
│            • 여러 모델 간 조정                                      │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    Data Layer (모델)                                │
│            • 데이터베이스 작업                                      │
│            • ORM 매핑                                               │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 5.2 인증 서비스 (app/services/auth.py)

### 5.2.1 JWT 인증 개념

```
JWT (JSON Web Token) 구조:
┌──────────────────────────────────────────────────────────────────────┐
│                         Header.Payload.Signature                     │
└──────────────────────────────────────────────────────────────────────┘
                    │           │           │
                    ▼           ▼           ▼
            ┌───────────┐  ┌──────────┐  ┌───────────┐
            │  Header   │  │ Payload  │  │ Signature │
            │ (헤더)    │  │ (데이터) │  │ (서명)    │
            ├───────────┤  ├──────────┤  ├───────────┤
            │ alg:HS256 │  │ sub: 123 │  │ HMAC-SHA  │
            │ typ: JWT  │  │ exp:...  │  │ 256 해시  │
            └───────────┘  │ type:... │  └───────────┘
                           └──────────┘
```

### 5.2.2 AuthService 클래스

```python
class AuthService:
    """
    인증 서비스

    사용자 인증과 관련된 모든 비즈니스 로직을 담당합니다:
    - 회원가입 (register)
    - 로그인 (login)
    - 토큰 갱신 (refresh_tokens)
    - 비밀번호 변경 (change_password)
    """

    def __init__(self, db: AsyncSession):
        self.db = db
        # UserService를 조합(composition)하여 재사용
        self.user_service = UserService(db)
```

### 5.2.3 회원가입 메서드

```python
async def register(self, user_in: UserCreate) -> User:
    """
    회원가입 처리

    흐름:
        1. 이메일 중복 확인
        2. 사용자명 중복 확인
        3. 비밀번호 해시화
        4. DB에 사용자 저장
        5. 생성된 사용자 반환
    """
    # Step 1: 이메일 중복 확인
    if await self.user_service.is_email_taken(user_in.email):
        raise ConflictError("이미 등록된 이메일입니다.")

    # Step 2: 사용자명 중복 확인
    if await self.user_service.is_username_taken(user_in.username):
        raise ConflictError("이미 사용중인 사용자명입니다.")

    # Step 3: 사용자 생성 (비밀번호 해시화 포함)
    user = await self.user_service.create(user_in)
    return user
```

### 5.2.4 로그인 메서드

```python
async def login(self, email: str, password: str) -> Token:
    """
    로그인 처리

    흐름:
        1. 이메일로 사용자 조회
        2. 비밀번호 검증 (bcrypt)
        3. 계정 활성 상태 확인
        4. Access Token 생성
        5. Refresh Token 생성
        6. 토큰 반환
    """
    # Step 1: 사용자 조회
    user = await self.user_service.get_by_email(email)
    if not user:
        raise AuthenticationError("이메일 또는 비밀번호가 올바르지 않습니다.")

    # Step 2: 비밀번호 검증
    if not verify_password(password, user.hashed_password):
        raise AuthenticationError("이메일 또는 비밀번호가 올바르지 않습니다.")

    # Step 3: 계정 상태 확인
    if not user.is_active:
        raise AuthenticationError("비활성화된 계정입니다.")

    # Step 4 & 5: 토큰 생성
    access_token = create_access_token(subject=user.id)
    refresh_token = create_refresh_token(subject=user.id)

    return Token(
        access_token=access_token,
        refresh_token=refresh_token,
    )
```

### 5.2.5 토큰 갱신 메서드

```python
async def refresh_tokens(self, refresh_token: str) -> Token:
    """
    토큰 갱신

    Access Token이 만료되었을 때 Refresh Token을 사용하여
    새로운 토큰 쌍을 발급합니다.

    토큰 로테이션:
        - Refresh Token도 매번 새로 발급
        - 한 번 사용된 토큰은 무효화
    """
    # Refresh Token 검증
    payload = verify_token(refresh_token, token_type="refresh")
    if not payload:
        raise AuthenticationError("유효하지 않은 토큰입니다.")

    # 사용자 조회 및 검증
    user_id = int(payload["sub"])
    user = await self.user_service.get_by_id(user_id)
    if not user or not user.is_active:
        raise AuthenticationError("사용자를 찾을 수 없습니다.")

    # 새 토큰 쌍 생성
    new_access_token = create_access_token(subject=user.id)
    new_refresh_token = create_refresh_token(subject=user.id)

    return Token(
        access_token=new_access_token,
        refresh_token=new_refresh_token,
    )
```

### 5.2.6 인증 흐름 다이어그램

```
┌─────────────────────────────────────────────────────────────────────┐
│                        로그인 (Login)                               │
└─────────────────────────────────────────────────────────────────────┘
     │
     ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────────────────────┐
│ 사용자 입력 │───►│ AuthService │───►│ Access Token + Refresh Token│
│ email/pass  │    │ login()     │    │ (httpOnly 쿠키로 저장)      │
└─────────────┘    └─────────────┘    └─────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│                     API 요청 (Authenticated)                        │
└─────────────────────────────────────────────────────────────────────┘
     │
     ▼
┌─────────────────────┐    ┌──────────────────┐    ┌────────────────┐
│ 브라우저가 쿠키     │───►│ get_current_user │───►│ 인증된 요청    │
│ 자동 전송           │    │ 의존성           │    │ 처리           │
└─────────────────────┘    └──────────────────┘    └────────────────┘

┌─────────────────────────────────────────────────────────────────────┐
│              토큰 갱신 (Access Token 만료 시)                       │
└─────────────────────────────────────────────────────────────────────┘
     │
     ▼
┌─────────────────────┐    ┌──────────────────────┐    ┌─────────────┐
│ Refresh Token       │───►│ AuthService          │───►│ 새 토큰 쌍  │
│ (쿠키에서)          │    │ refresh_tokens()     │    │ 발급        │
└─────────────────────┘    └──────────────────────┘    └─────────────┘
```

---

## 5.3 사용자 서비스 (app/services/user.py)

### 5.3.1 UserService 클래스

```python
class UserService:
    """사용자 서비스"""

    def __init__(self, db: AsyncSession):
        self.db = db
```

### 5.3.2 CRUD 메서드

```python
async def get_by_id(self, user_id: int) -> Optional[User]:
    """ID로 사용자 조회"""
    result = await self.db.execute(select(User).where(User.id == user_id))
    return result.scalar_one_or_none()


async def get_by_email(self, email: str) -> Optional[User]:
    """이메일로 사용자 조회"""
    result = await self.db.execute(select(User).where(User.email == email))
    return result.scalar_one_or_none()


async def get_by_username(self, username: str) -> Optional[User]:
    """사용자명으로 조회"""
    result = await self.db.execute(select(User).where(User.username == username))
    return result.scalar_one_or_none()


async def get_all(
    self,
    skip: int = 0,
    limit: int = 100,
    is_active: Optional[bool] = None,
) -> list[User]:
    """사용자 목록 조회 (페이지네이션, 필터링)"""
    query = select(User)

    if is_active is not None:
        query = query.where(User.is_active == is_active)

    query = query.offset(skip).limit(limit)
    result = await self.db.execute(query)
    return list(result.scalars().all())
```

### 5.3.3 생성/수정/삭제 메서드

```python
async def create(self, user_in: UserCreate) -> User:
    """사용자 생성"""
    user = User(
        email=user_in.email,
        username=user_in.username,
        full_name=user_in.full_name,
        hashed_password=get_password_hash(user_in.password),  # 해시화!
    )
    self.db.add(user)
    await self.db.flush()      # DB에 전송 (커밋 아님)
    await self.db.refresh(user) # 최신 데이터 반영 (ID 등)
    return user


async def update(self, user: User, user_in: UserUpdate) -> User:
    """사용자 정보 수정"""
    update_data = user_in.model_dump(exclude_unset=True)

    # 비밀번호가 있으면 해싱
    if "password" in update_data:
        update_data["hashed_password"] = get_password_hash(
            update_data.pop("password")
        )

    for field, value in update_data.items():
        setattr(user, field, value)

    await self.db.flush()
    await self.db.refresh(user)
    return user


async def delete(self, user: User) -> None:
    """사용자 삭제"""
    await self.db.delete(user)
    await self.db.flush()
```

### 5.3.4 유틸리티 메서드

```python
async def is_email_taken(
    self,
    email: str,
    exclude_user_id: Optional[int] = None
) -> bool:
    """이메일 중복 확인"""
    query = select(User).where(User.email == email)
    if exclude_user_id:
        query = query.where(User.id != exclude_user_id)
    result = await self.db.execute(query)
    return result.scalar_one_or_none() is not None


async def is_username_taken(
    self,
    username: str,
    exclude_user_id: Optional[int] = None
) -> bool:
    """사용자명 중복 확인"""
    query = select(User).where(User.username == username)
    if exclude_user_id:
        query = query.where(User.id != exclude_user_id)
    result = await self.db.execute(query)
    return result.scalar_one_or_none() is not None
```

---

## 5.4 아이템 서비스 (app/services/item.py)

### 5.4.1 ItemService 클래스

```python
class ItemService:
    """아이템 서비스"""

    def __init__(self, db: AsyncSession):
        self.db = db
```

### 5.4.2 조회 메서드

```python
async def get_by_id(
    self,
    item_id: int,
    owner_id: Optional[int] = None,
) -> Optional[Item]:
    """ID로 아이템 조회 (소유자 검증 옵션)"""
    query = select(Item).where(Item.id == item_id)
    if owner_id:
        query = query.where(Item.owner_id == owner_id)
    result = await self.db.execute(query)
    return result.scalar_one_or_none()


async def get_by_id_with_owner(self, item_id: int) -> Optional[Item]:
    """소유자 정보 포함 조회 (JOIN)"""
    query = (
        select(Item)
        .options(joinedload(Item.owner))  # Eager Loading
        .where(Item.id == item_id)
    )
    result = await self.db.execute(query)
    return result.scalar_one_or_none()


async def get_all(
    self,
    owner_id: Optional[int] = None,
    skip: int = 0,
    limit: int = 100,
    is_active: Optional[bool] = None,
    search: Optional[str] = None,
) -> list[Item]:
    """아이템 목록 조회"""
    query = select(Item)

    # 필터링
    if owner_id:
        query = query.where(Item.owner_id == owner_id)
    if is_active is not None:
        query = query.where(Item.is_active == is_active)
    if search:
        query = query.where(
            Item.title.ilike(f"%{search}%")
            | Item.description.ilike(f"%{search}%")
        )

    # 정렬 및 페이지네이션
    query = query.order_by(Item.priority.desc(), Item.created_at.desc())
    query = query.offset(skip).limit(limit)

    result = await self.db.execute(query)
    return list(result.scalars().all())


async def count(
    self,
    owner_id: Optional[int] = None,
    is_active: Optional[bool] = None,
    search: Optional[str] = None,
) -> int:
    """아이템 개수 조회"""
    query = select(func.count(Item.id))

    if owner_id:
        query = query.where(Item.owner_id == owner_id)
    if is_active is not None:
        query = query.where(Item.is_active == is_active)
    if search:
        query = query.where(
            Item.title.ilike(f"%{search}%")
            | Item.description.ilike(f"%{search}%")
        )

    result = await self.db.execute(query)
    return result.scalar() or 0
```

### 5.4.3 CUD 메서드

```python
async def create(self, item_in: ItemCreate, owner: User) -> Item:
    """아이템 생성"""
    item = Item(
        title=item_in.title,
        description=item_in.description,
        priority=item_in.priority,
        owner_id=owner.id,
    )
    self.db.add(item)
    await self.db.flush()
    await self.db.refresh(item)
    return item


async def update(self, item: Item, item_in: ItemUpdate) -> Item:
    """아이템 수정"""
    update_data = item_in.model_dump(exclude_unset=True)

    for field, value in update_data.items():
        setattr(item, field, value)

    await self.db.flush()
    await self.db.refresh(item)
    return item


async def delete(self, item: Item) -> None:
    """아이템 삭제"""
    await self.db.delete(item)
    await self.db.flush()


async def toggle_active(self, item: Item) -> Item:
    """활성/비활성 토글"""
    item.is_active = not item.is_active
    await self.db.flush()
    await self.db.refresh(item)
    return item
```

### 5.4.4 404 처리 헬퍼

```python
async def get_or_404(
    self,
    item_id: int,
    owner_id: Optional[int] = None,
) -> Item:
    """아이템 조회 (없으면 404 에러)"""
    item = await self.get_by_id(item_id, owner_id)
    if not item:
        raise NotFoundError("아이템을 찾을 수 없습니다.")
    return item
```

---

## 5.5 서비스 레이어의 장점

### 5.5.1 코드 재사용

```python
# 여러 라우터에서 같은 서비스 사용
# API 라우터
@router.post("/items")
async def create_item(item_service: Annotated[ItemService, Depends(get_item_service)]):
    ...

# 파셜 라우터
@router.post("/partials/items")
async def create_item_partial(item_service: Annotated[ItemService, Depends(get_item_service)]):
    ...
```

### 5.5.2 테스트 용이성

```python
# 서비스 단위 테스트
async def test_create_user():
    # Mock DB 세션
    mock_db = AsyncMock()

    # 서비스 인스턴스 생성
    service = UserService(mock_db)

    # 테스트 실행
    user = await service.create(user_data)

    # 검증
    assert user.email == "test@example.com"
```

### 5.5.3 비즈니스 로직 집중화

```python
# 서비스: 비즈니스 로직만 담당
class AuthService:
    async def register(self, user_in: UserCreate):
        # 1. 이메일 중복 확인
        # 2. 사용자명 중복 확인
        # 3. 비밀번호 해시화
        # 4. 사용자 생성
        ...

# 라우터: HTTP 처리만 담당
@router.post("/register")
async def register(user_in: UserCreate, auth_service: ...):
    user = await auth_service.register(user_in)
    return user
```

---

## 5.6 flush vs commit

| 메서드 | 동작 | 사용 시점 |
|--------|------|-----------|
| `flush()` | DB에 쿼리 전송 (커밋 X) | ID 생성 필요 시 |
| `commit()` | 트랜잭션 확정 | 요청 완료 시 (get_db에서 자동) |
| `rollback()` | 트랜잭션 취소 | 에러 발생 시 (get_db에서 자동) |

```python
async def create(self, user_in: UserCreate) -> User:
    user = User(...)
    self.db.add(user)
    await self.db.flush()       # ← ID가 생성됨 (auto_increment)
    await self.db.refresh(user) # ← user.id 사용 가능
    return user
    # commit은 get_db()에서 자동으로 수행
```
